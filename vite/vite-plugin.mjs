import { mkdir, writeFile } from "node:fs/promises";

const PLUGIN_NAME = "@winglibs/vite";
const DEFAULT_TYPES_DIRECTORY = ".winglibs";

/**
 * @param {{
 *  env: string;
 *  envName: string;
 *  generateTypeDefinitions: boolean;
 *  typeDefinitionsDirectory: string;
 * }} options
 * @return {import("vite").Plugin}
 */
export const plugin = (options) => {
  /**
   * @type {{
   *  root?: string;
   * }}
   */
  const context = {};
  return {
    name: PLUGIN_NAME,
    configResolved(config) {
      context.root = config.root;
    },
    transformIndexHtml(html) {
      return html.replace(
        "<head>",
        `<head>\n    <script>window.${options.envName}=Object.freeze({meta:Object.freeze({env:${options.env}})});</script>`
      );
    },
    async buildStart() {
      if (!options.generateTypeDefinitions) {
        return;
      }

      if (!context.root) {
        throw new Error("[root] is missing");
      }

      const root = `file://${context.root}/`;

      this.info("Generating type definitions...");
      let dts = [
        `// Generated by \`${PLUGIN_NAME}\`. Do not edit.`,
        `/** Holds environment variables generated from Wing. */`,
        "interface WingEnv {",
      ];
      try {
        const env = options.env ? JSON.parse(options.env) : {};
        for (const [key, value] of Object.entries(env)) {
          const type = typeof value === "string" ? "string" : "unknown";
          dts.push(`\treadonly ${key}: ${type};`);
        }
      } catch (error) {
        this.error(
          error instanceof Error
            ? error
            : new Error("Unknown error", { cause: error })
        );
      }
      dts.push(
        // "\t};",
        "}",
        "interface Wing { env: WingEnv; }",
        `declare var ${options.envName}: Wing;`,
        "interface Window {",
        `\treadonly ${options.envName}: Wing;`,
        "}",
        ""
      );
      console.log(dts);

      const dir = new URL(
        `${options.typeDefinitionsDirectory ?? DEFAULT_TYPES_DIRECTORY}/`,
        root
      );
      await mkdir(dir, { recursive: true });
      await writeFile(new URL("env.d.ts", dir), dts.join("\n"));
    },
  };
};
